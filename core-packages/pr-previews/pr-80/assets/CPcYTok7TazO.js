import{U as D,i as f,W as L,r as l,d as g,f as m,j as a,u as $,X as _,Y as z,Z as b,t as q}from"./CWtKTwDlsiso.js";import{c as F}from"./sXrrPFqGgNvc.js";import{u as y,n as G}from"./1lO_9NHhCSJ8.js";import{a as A,u as V}from"./C5tmr20VyEU8.js";import{a as u,c as W}from"./CzEOX7A84PJH.js";const C=t=>F()(t,["immediate","lazyMount","onExitComplete","present","unmountOnExit"]);function X(t,e,r){const n=t.matches("mounted","unmountSuspended");return{skip:!t.context.initial&&n,present:n,setNode(o){o&&e({type:"NODE.SET",node:o})},unmount(){e({type:"UNMOUNT"})}}}function Y(t){return D({initial:t.present?"mounted":"unmounted",context:{node:null,styles:null,unmountAnimationName:null,prevAnimationName:null,present:!1,initial:!1,...t},exit:["clearInitial","cleanupNode"],watch:{present:["setInitial","syncPresence"]},on:{"NODE.SET":{actions:["setNode","setStyles"]}},states:{mounted:{on:{UNMOUNT:{target:"unmounted",actions:["invokeOnExitComplete"]},"UNMOUNT.SUSPEND":"unmountSuspended"}},unmountSuspended:{activities:["trackAnimationEvents"],after:{ANIMATION_DURATION:{target:"unmounted",actions:["invokeOnExitComplete"]}},on:{MOUNT:{target:"mounted",actions:["setPrevAnimationName"]},UNMOUNT:{target:"unmounted",actions:["invokeOnExitComplete"]}}},unmounted:{entry:["clearPrevAnimationName"],on:{MOUNT:{target:"mounted",actions:["setPrevAnimationName"]}}}}},{delays:{ANIMATION_DURATION(e){return v(e.styles?.animationDuration)+v(e.styles?.animationDelay)+Z}},actions:{setInitial(e){e.initial=!0},clearInitial(e){e.initial=!1},cleanupNode(e){e.node=null,e.styles=null},invokeOnExitComplete(e){e.onExitComplete?.()},setNode(e,r){e.node=f(r.node)},setStyles(e,r){const n=r.node.ownerDocument.defaultView||window;e.styles=f(n.getComputedStyle(r.node))},syncPresence(e,r,{send:n}){if(e.present){n({type:"MOUNT",src:"presence.changed"});return}if(!e.present&&e.node?.ownerDocument.visibilityState==="hidden"){n({type:"UNMOUNT",src:"visibilitychange"});return}const o=P(e.styles);(e.immediate?queueMicrotask:requestAnimationFrame)(()=>{e.unmountAnimationName=o,o==="none"||o===e.prevAnimationName||e.styles?.display==="none"||e.styles?.animationDuration==="0s"?n({type:"UNMOUNT",src:"presence.changed"}):n({type:"UNMOUNT.SUSPEND"})})},setPrevAnimationName(e){(e.immediate?queueMicrotask:requestAnimationFrame)(()=>{e.prevAnimationName=P(e.styles)})},clearPrevAnimationName(e){e.prevAnimationName=null}},activities:{trackAnimationEvents(e,r,{send:n}){const o=e.node;if(!o)return;const s=c=>{(c.composedPath?.()?.[0]??c.target)===o&&(e.prevAnimationName=P(e.styles))},i=c=>{const T=P(e.styles);(c.composedPath?.()?.[0]??c.target)===o&&T===e.unmountAnimationName&&n({type:"UNMOUNT",src:"animationend"})};return o.addEventListener("animationstart",s),o.addEventListener("animationcancel",i),o.addEventListener("animationend",i),()=>{o.removeEventListener("animationstart",s),o.removeEventListener("animationcancel",i),o.removeEventListener("animationend",i)}}}})}function P(t){return t?.animationName||"none"}function v(t){return parseFloat(t||"0")*1e3}var Z=16.667;L()(["onExitComplete","present","immediate"]);const E=t=>{const{lazyMount:e,unmountOnExit:r,present:n,...o}=t,s=l.useRef(!1),i={...o,present:n,onExitComplete:A(t.onExitComplete)},[c,T]=y(Y(i),{context:i}),p=X(c,T);p.present&&(s.current=!0);const I=!p.present&&!s.current&&e||r&&!p.present&&s.current,j=()=>({"data-state":n?"open":"closed",hidden:!p.present});return{ref:p.setNode,getPresenceProps:j,present:p.present,unmounted:I}},[w,x]=g({name:"PresenceContext",hookName:"usePresenceContext",providerName:"<PresenceProvider />"}),[h,d]=g({name:"TooltipContext",hookName:"useTooltipContext",providerName:"<TooltipProvider />"}),O=l.forwardRef((t,e)=>{const r=d(),n=m(r.getArrowProps(),t);return a.jsx(u.div,{...n,ref:e})});O.displayName="TooltipArrow";const U=l.forwardRef((t,e)=>{const r=d(),n=m(r.getArrowTipProps(),t);return a.jsx(u.div,{...n,ref:e})});U.displayName="TooltipArrowTip";const M=l.forwardRef((t,e)=>{const r=d(),n=x(),o=m(r.getContentProps(),n.getPresenceProps(),t);return n.unmounted?null:a.jsx(u.div,{...o,ref:W(n.ref,e)})});M.displayName="TooltipContent";const R=l.forwardRef((t,e)=>{const r=d(),n=m(r.getPositionerProps(),t);return x().unmounted?null:a.jsx(u.div,{...n,ref:e})});R.displayName="TooltipPositioner";const B=(t={})=>{const{getRootNode:e}=$(),{dir:r}=V(),n={id:l.useId(),dir:r,getRootNode:e,open:t.defaultOpen,"open.controlled":t.open!==void 0,...t},o={...n,onOpenChange:A(t.onOpenChange,{sync:!0})},[s,i]=y(_(n),{context:o});return z(s,i,G)},H=t=>{const[e,{children:r,...n}]=C(t),o=B(n),s=E(m({present:o.open},e));return a.jsx(h,{value:o,children:a.jsx(w,{value:s,children:r})})},J=t=>{const[e,{value:r,children:n}]=C(t),o=E(m({present:r.open},e));return a.jsx(h,{value:r,children:a.jsx(w,{value:o,children:n})})},k=l.forwardRef((t,e)=>{const r=d(),n=m(r.getTriggerProps(),t);return a.jsx(u.button,{...n,ref:e})});k.displayName="TooltipTrigger";const{withContext:K}=b({key:"link"}),re=K("a"),{withRootProvider:S,withContext:N}=q({key:"tooltip"});S(J);const se=S(H,{defaultProps:{lazyMount:!0,unmountOnExit:!0}}),ie=N(k,"trigger",{forwardAsChild:!0}),ae=N(R,"positioner",{forwardAsChild:!0}),ce=N(M,"content",{forwardAsChild:!0}),pe=N(O,"arrow",{forwardAsChild:!0}),le=N(U,"arrowTip",{forwardAsChild:!0});export{re as L,w as P,se as T,x as a,ie as b,ae as c,ce as d,pe as e,le as f,C as s,E as u};
