import{a_ as h,af as c,bQ as a,ay as b,bR as w,ak as F,an as S,am as M,bS as C,bT as N,bU as L,bV as k,ac as A,bW as d,bX as G,bY as J}from"./CSmiKdizJP8d.js";import{G as R,a as x,b as T,M as E}from"./Cqi0VnO_D_SD.js";import{L as _}from"./ZELZeNiQy5tD.js";class U{constructor(){this.dataProjection=void 0,this.defaultFeatureProjection=void 0,this.featureClass=h,this.supportedMediaTypes=null}getReadOptions(e,t){if(t){let n=t.dataProjection?c(t.dataProjection):this.readProjection(e);t.extent&&n&&n.getUnits()==="tile-pixels"&&(n=c(n),n.setWorldExtent(t.extent)),t={dataProjection:n,featureProjection:t.featureProjection}}return this.adaptOptions(t)}adaptOptions(e){return Object.assign({dataProjection:this.dataProjection,featureProjection:this.defaultFeatureProjection,featureClass:this.featureClass},e)}getType(){return a()}readFeature(e,t){return a()}readFeatures(e,t){return a()}readGeometry(e,t){return a()}readProjection(e){return a()}writeFeature(e,t){return a()}writeFeatures(e,t){return a()}writeGeometry(e,t){return a()}}function g(r,e,t){const n=t?c(t.featureProjection):null,o=t?c(t.dataProjection):null;let i=r;if(n&&o&&!b(n,o)){e&&(i=r.clone());const s=e?n:o,u=e?o:n;s.getUnits()==="tile-pixels"?i.transform(s,u):i.applyTransform(w(s,u))}if(e&&t&&t.decimals!==void 0){const s=Math.pow(10,t.decimals),u=function(y){for(let l=0,j=y.length;l<j;++l)y[l]=Math.round(y[l]*s)/s;return y};i===r&&(i=r.clone()),i.applyTransform(u)}return i}const I={Point:S,LineString:_,Polygon:M,MultiPoint:x,MultiLineString:T,MultiPolygon:E};function W(r,e,t){return Array.isArray(e[0])?(C(r,0,e,t)||(r=r.slice(),N(r,0,e,t)),r):(L(r,0,e,t)||(r=r.slice(),k(r,0,e,t)),r)}function O(r,e){const t=r.geometry;if(!t)return[];if(Array.isArray(t))return t.map(i=>O({...r,geometry:i})).flat();const n=t.type==="MultiPolygon"?"Polygon":t.type;if(n==="GeometryCollection"||n==="Circle")throw new Error("Unsupported geometry type: "+n);const o=t.layout.length;return g(new F(n,n==="Polygon"?W(t.flatCoordinates,t.ends,o):t.flatCoordinates,t.ends?.flat(),o,r.properties||{},r.id).enableSimplifyTransformed(),!1,e)}function p(r,e){if(!r)return null;if(Array.isArray(r)){const n=r.map(o=>p(o,e));return new R(n)}const t=I[r.type];return g(new t(r.flatCoordinates,r.layout,r.ends),!1,e)}class v extends U{constructor(){super()}getType(){return"json"}readFeature(e,t){return this.readFeatureFromObject(f(e),this.getReadOptions(e,t))}readFeatures(e,t){return this.readFeaturesFromObject(f(e),this.getReadOptions(e,t))}readFeatureFromObject(e,t){return a()}readFeaturesFromObject(e,t){return a()}readGeometry(e,t){return this.readGeometryFromObject(f(e),this.getReadOptions(e,t))}readGeometryFromObject(e,t){return a()}readProjection(e){return this.readProjectionFromObject(f(e))}readProjectionFromObject(e){return a()}writeFeature(e,t){return JSON.stringify(this.writeFeatureObject(e,t))}writeFeatureObject(e,t){return a()}writeFeatures(e,t){return JSON.stringify(this.writeFeaturesObject(e,t))}writeFeaturesObject(e,t){return a()}writeGeometry(e,t){return JSON.stringify(this.writeGeometryObject(e,t))}writeGeometryObject(e,t){return a()}}function f(r){if(typeof r=="string"){const e=JSON.parse(r);return e||null}return r!==null?r:null}class ae extends v{constructor(e){e=e||{},super(),this.dataProjection=c(e.dataProjection?e.dataProjection:"EPSG:4326"),e.featureProjection&&(this.defaultFeatureProjection=c(e.featureProjection)),e.featureClass&&(this.featureClass=e.featureClass),this.geometryName_=e.geometryName,this.extractGeometryName_=e.extractGeometryName,this.supportedMediaTypes=["application/geo+json","application/vnd.geo+json"]}readFeatureFromObject(e,t){let n=null;e.type==="Feature"?n=e:n={type:"Feature",geometry:e,properties:null};const o=P(n.geometry);if(this.featureClass===F)return O({geometry:o,id:n.id,properties:n.properties},t);const i=new h;return this.geometryName_?i.setGeometryName(this.geometryName_):this.extractGeometryName_&&n.geometry_name&&i.setGeometryName(n.geometry_name),i.setGeometry(p(o,t)),"id"in n&&i.setId(n.id),n.properties&&i.setProperties(n.properties,!0),i}readFeaturesFromObject(e,t){const n=e;let o=null;if(n.type==="FeatureCollection"){const i=e;o=[];const s=i.features;for(let u=0,y=s.length;u<y;++u){const l=this.readFeatureFromObject(s[u],t);l&&o.push(l)}}else o=[this.readFeatureFromObject(e,t)];return o.flat()}readGeometryFromObject(e,t){return H(e,t)}readProjectionFromObject(e){const t=e.crs;let n;if(t)if(t.type=="name")n=c(t.properties.name);else if(t.type==="EPSG")n=c("EPSG:"+t.properties.code);else throw new Error("Unknown SRS type");else n=this.dataProjection;return n}writeFeatureObject(e,t){t=this.adaptOptions(t);const n={type:"Feature",geometry:null,properties:null},o=e.getId();if(o!==void 0&&(n.id=o),!e.hasProperties())return n;const i=e.getProperties(),s=e.getGeometry();return s&&(n.geometry=m(s,t),delete i[e.getGeometryName()]),A(i)||(n.properties=i),n}writeFeaturesObject(e,t){t=this.adaptOptions(t);const n=[];for(let o=0,i=e.length;o<i;++o)n.push(this.writeFeatureObject(e[o],t));return{type:"FeatureCollection",features:n}}writeGeometryObject(e,t){return m(e,this.adaptOptions(t))}}function P(r,e){if(!r)return null;let t;switch(r.type){case"Point":{t=Q(r);break}case"LineString":{t=V(r);break}case"Polygon":{t=B(r);break}case"MultiPoint":{t=Y(r);break}case"MultiLineString":{t=X(r);break}case"MultiPolygon":{t=z(r);break}case"GeometryCollection":{t=q(r);break}default:throw new Error("Unsupported GeoJSON type: "+r.type)}return t}function H(r,e){const t=P(r);return p(t,e)}function q(r,e){return r.geometries.map(function(n){return P(n)})}function Q(r){const e=r.coordinates;return{type:"Point",flatCoordinates:e,layout:d(e.length)}}function V(r){const e=r.coordinates,t=e.flat();return{type:"LineString",flatCoordinates:t,ends:[t.length],layout:d(e[0]?.length||2)}}function X(r){const e=r.coordinates,t=e[0]?.[0]?.length||2,n=[],o=G(n,0,e,t);return{type:"MultiLineString",flatCoordinates:n,ends:o,layout:d(t)}}function Y(r){const e=r.coordinates;return{type:"MultiPoint",flatCoordinates:e.flat(),layout:d(e[0]?.length||2)}}function z(r){const e=r.coordinates,t=[],n=e[0]?.[0]?.[0].length||2,o=J(t,0,e,n);return{type:"MultiPolygon",flatCoordinates:t,ends:o,layout:d(n)}}function B(r){const e=r.coordinates,t=[],n=e[0]?.[0]?.length,o=G(t,0,e,n);return{type:"Polygon",flatCoordinates:t,ends:o,layout:d(n)}}function m(r,e){r=g(r,!0,e);const t=r.getType();let n;switch(t){case"Point":{n=te(r);break}case"LineString":{n=K(r);break}case"Polygon":{n=re(r,e);break}case"MultiPoint":{n=$(r);break}case"MultiLineString":{n=Z(r);break}case"MultiPolygon":{n=ee(r,e);break}case"GeometryCollection":{n=D(r,e);break}case"Circle":{n={type:"GeometryCollection",geometries:[]};break}default:throw new Error("Unsupported geometry type: "+t)}return n}function D(r,e){return e=Object.assign({},e),delete e.featureProjection,{type:"GeometryCollection",geometries:r.getGeometriesArray().map(function(n){return m(n,e)})}}function K(r,e){return{type:"LineString",coordinates:r.getCoordinates()}}function Z(r,e){return{type:"MultiLineString",coordinates:r.getCoordinates()}}function $(r,e){return{type:"MultiPoint",coordinates:r.getCoordinates()}}function ee(r,e){let t;return e&&(t=e.rightHanded),{type:"MultiPolygon",coordinates:r.getCoordinates(t)}}function te(r,e){return{type:"Point",coordinates:r.getCoordinates()}}function re(r,e){let t;return e&&(t=e.rightHanded),{type:"Polygon",coordinates:r.getCoordinates(t)}}export{U as F,ae as G,g as t};
